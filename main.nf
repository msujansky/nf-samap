#!/usr/env/bin nextflow

/*
 *  PIPELINE: main.nf
 *
 *  Description:
 *      SAMap-based cross-species transcriptome mapping pipeline.
 *      Performs preprocessing of input metadata, reciprocal BLAST between
 *      species, SAMap alignment, and visualization of results.
 *
 *  Inputs:
 *      - data/transcriptomes/*.fasta      Input transcriptome FASTA files
 *      - data/*.h5ad                      Precomputed AnnData files
 *      - sample_sheet.csv                 Sample metadata sheet
 *
 *  Workflow Overview:
 *      1. Preprocess sample sheet to classify inputs and assign IDs
 *      2. Generate all unordered species pairs
 *      3. Run reciprocal BLAST on each species pair
 *      4. Build a SAMap object
 *      5. Run SAMap on each BLAST result
 *      6. Visualize SAMap alignment and write results
 *
 *  Parameters:
 *      --run_id        Run ID provided by user. If none is provided a timestamp is used. Default: null
 *      --sample_sheet  Path to the sample sheet provided by user. Default: 'sample_sheet.csv'
 *      --maps_dir      Path to a directory containing precomputed BLAST maps if any are provided. 
 *                      Any value other than null will skip the BLAST module. Default: null
 *      --outdir   The directory all where all results will be stored. Default: '.'
 *
 *  Outputs:
 *      - results_dir/run_id/sample_sheet.csv       Updated metadata with type and ID
 *      - results_dir/run_id/maps/                  Reciprocal BLAST outputs per sample pair
 *      - results_dir/run_id/samap_objects/         Pickled SAMap object (Python)
 *      - results_dir/run_id/plots/chord.html       Chord plot
 *      - results_dir/run_id/plots/sankey.html      Mapping Sankey diagram
 *      - results_dir/run_id/plots/scatter.png      Gene mapping scatter plot
 *      - results_dir/run_id/csv/hms.csv            Highest mapping scores (HMS) matrix
 *      - results_dir/run_id/csv/pms.csv            Pairwise mapping scores (PMS) matrix
 *      - results_dir/run_id/logs/*.log             Logfiles generated by the modules.
 *
 *  Author:     Markus Sujansky, Ryan Sonderman
 *  Created:    2025-06-12
 *  Last Modified: 2025-09-10
 *  Version:    1.0.2
 */

// Import the required modules 
include { PREPROCESS } from './modules/preprocess.nf'
include { RUN_BLAST_PAIR } from './modules/run_blast_pair.nf'
include { LOAD_SAMS } from './modules/load_sams.nf'
include { BUILD_SAMAP } from './modules/build_samap.nf'
include { RUN_SAMAP } from './modules/run_samap.nf'
include { VISUALIZE_SAMAP } from './modules/visualize_samap.nf'
include { validateParameters; paramsHelp; samplesheetToList } from 'plugin/nf-schema'

workflow {
    // Generate run ID unless one is provided
    run_id = params.run_id ?: "${new Date().format('yyyyMMdd_HHmmss')}"
    run_id_ch = Channel.value(run_id)

    // Stage static input files
    sample_sheet    = Channel.fromPath(params.sample_sheet)

    // Validation of necessary files
    if (!new File(params.sample_sheet).exists()) {
        error "Missing required file: sample sheet '${params.sample_sheet}'"
    }

    // Preprocess sample sheet to add type and ID
    PREPROCESS(
        run_id_ch,
        sample_sheet
    )
    
    // Reformat output of preprocessing step to remove necessity of Sample_Sheet for downstream processes
    PREPROCESS.out.sample_sheet_pr
        .map { file -> 
            def list = samplesheetToList(file.toString(), "./nf-samap/assets/schema_input.json")
            return list
        }
        .flatten()
        .collate(3)
        .set { ch_samples }
    


    // Generate unique unordered sample pairs
    pairs_channel = ch_samples
        .combine(ch_samples)
        .filter { a,b,c,d,e,f -> a.id2 < d.id2 }  

    // Run BLAST or load precomputed map files 
   if (params.maps_dir) {
        // Use user-supplied BLAST maps
        maps_dir = Channel.fromPath(params.maps_dir)
    } else {
        // Run BLAST and extract parent maps directory
        RUN_BLAST_PAIR(
            run_id_ch,
            pairs_channel.map{[it[0], it[3], it[2], it[5]]}
        )
        // Set path to maps from BLAST results
    maps_dir = RUN_BLAST_PAIR.out.maps
    }

    // Grab all id2 values, to be used in LOAD_SAMS to reference the appropriate SAM object
    id2 = ch_samples
    .map { tuple ->
        def (meta, h5ad, fasta) = tuple
        return meta.id2
    }
    .collect()

    // Grab all h5ad paths, to be used in LOAD_SAMS to reference the appropriate SAM object
    h5ad = ch_samples
    .map { tuple ->
        def (meta, h5ad, fasta) = tuple
        return h5ad
    }
    .collect()
    
    //Combine into a single channel obj
    condensedSampleSheet = id2
        .map { ids -> [ ids, h5ad.getVal() ] }
    condensedSampleSheet
    
    // Load SAM objects from the AnnData h5ad files
    LOAD_SAMS(
        run_id_ch,
        condensedSampleSheet
    )
    sams = LOAD_SAMS.out.sams
  
    // Build the SAMap object from the SAM objects and the BLAST maps
    BUILD_SAMAP(
        run_id_ch,
        condensedSampleSheet,
        maps_dir,
        sams
    )
    samap = BUILD_SAMAP.out.samap

    // Run SAMap on the SAMAP object to generate mapping results
    RUN_SAMAP(
        run_id_ch,
        samap
    )
    samap_results = RUN_SAMAP.out.results

    // Building channel obj for visualization module
    anno = ch_samples
    .map { tuple ->
        def (meta, h5ad, fasta) = tuple
        return meta.annotation
    }
    .collect()

    annotations = id2
        .map { ids -> [ ids, anno.getVal()] }
    annotations.view()

    // Visualize the SAMap results
     VISUALIZE_SAMAP(
        run_id_ch,
        samap_results,
        annotations
    )  
}
